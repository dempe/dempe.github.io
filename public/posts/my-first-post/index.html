<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta http-equiv="X-Clacks-Overhead"/>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,user-scalable=0" />
<title>Minimalistic Dotfile Management | Shoshin</title>
<meta name="title" content="Minimalistic Dotfile Management" />
<meta name="description" content="Keeping your dotfiles in source control makes them consistent across time (e.g., revert to a previous version) and space (e.g., deploy to a new environment) and makes them shareable with the world. This isn&rsquo;t new. But what incantation of symlinks, submodules, and scripts is best?
I prefer to use vanilla Git.
Setup Start by initializing a Git repository in your home directory. Then exclude everything.
git init &amp;&amp; echo &#39;*&#39; &gt; ." />
<meta name="keywords" content="software," />


<meta property="og:title" content="Minimalistic Dotfile Management" />
<meta property="og:description" content="Keeping your dotfiles in source control makes them consistent across time (e.g., revert to a previous version) and space (e.g., deploy to a new environment) and makes them shareable with the world. This isn&rsquo;t new. But what incantation of symlinks, submodules, and scripts is best?
I prefer to use vanilla Git.
Setup Start by initializing a Git repository in your home directory. Then exclude everything.
git init &amp;&amp; echo &#39;*&#39; &gt; ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chrisdempewolf.com/posts/my-first-post/" />
<meta property="article:published_time" content="2020-09-15T11:05:52-05:00" />
<meta property="article:modified_time" content="2020-09-15T11:05:52-05:00" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Minimalistic Dotfile Management"/>
<meta name="twitter:description" content="Keeping your dotfiles in source control makes them consistent across time (e.g., revert to a previous version) and space (e.g., deploy to a new environment) and makes them shareable with the world. This isn&rsquo;t new. But what incantation of symlinks, submodules, and scripts is best?
I prefer to use vanilla Git.
Setup Start by initializing a Git repository in your home directory. Then exclude everything.
git init &amp;&amp; echo &#39;*&#39; &gt; ."/>



<meta itemprop="name" content="Minimalistic Dotfile Management">
<meta itemprop="description" content="Keeping your dotfiles in source control makes them consistent across time (e.g., revert to a previous version) and space (e.g., deploy to a new environment) and makes them shareable with the world. This isn&rsquo;t new. But what incantation of symlinks, submodules, and scripts is best?
I prefer to use vanilla Git.
Setup Start by initializing a Git repository in your home directory. Then exclude everything.
git init &amp;&amp; echo &#39;*&#39; &gt; .">
<meta itemprop="datePublished" content="2020-09-15T11:05:52-05:00" />
<meta itemprop="dateModified" content="2020-09-15T11:05:52-05:00" />
<meta itemprop="wordCount" content="406">



<meta itemprop="keywords" content="software," />

<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: white;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #eee;
  }

  pre code {
    border-left: 1px solid #999;
    color: #555;
    display: block;
    padding: 10px;
    white-space: pre-wrap;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #555;
    padding-left: 10px;
    font-style: italic;
  }

  footer {
    margin-top: 100px;
    font-style: italic;
  }

  header {
    margin-bottom: 50px;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

</style>

</head>

<body>
  <header><a href="/" class="title">
  <h2>Shoshin</h2>
</a>
<nav><a href="/">Home</a>

<a href="/posts/">Posts</a>

<a href="/tags/">Tags</a>


</nav>
</header>
  <main>

<content>
  <p>Keeping your dotfiles in source control makes them consistent across time (e.g., revert to a previous version) and space (e.g., deploy to a new environment) and makes them shareable with the world. This isn&rsquo;t new. But what incantation of symlinks, submodules, and scripts is best?</p>
<p>I prefer to use vanilla Git.</p>
<h2 id="setup">Setup</h2>
<p>Start by initializing a Git repository in your home directory. Then exclude everything.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">git init <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#39;*&#39;</span> &gt; .gitignore
</code></pre></div><p>Whitelisting has a lot of benefits. Most importantly, <code>git clean</code> won&rsquo;t wipe all untracked files.</p>
<p>Selectively add files to Git:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">git add -f .vimrc
</code></pre></div><p>You must pass the <code>-f</code> option to <code>git add</code> since all files necessarily match your exclude pattern.</p>
<p>If you use plugins for things like Vim or Zsh, you can add them as Git submodules:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">git submodule add -f git@github.com:tpope/vim-commentary.git .vim/bundle/
</code></pre></div><p>Here&rsquo;s how to replicate this on a new workstation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">cd ~
git init .
git remote add origin &lt;dotfiles-repo-url&gt;
git pull origin master
</code></pre></div><p>And that&rsquo;s it. No symlinks, no install scripts, just plain ole Git.</p>
<p>Here&rsquo;s what <a href="https://github.com/dempe/dotfiles">my dotfiles repository</a> looks like.</p>
<h2 id="alternative-methods">Alternative Methods</h2>
<p><a href="https://medium.com/@webprolific/getting-started-with-dotfiles-43c3602fd789">Many</a> <a href="https://www.anishathalye.com/2014/08/03/managing-your-dotfiles/">methods</a> <a href="https://medium.com/@driesvints/getting-started-with-dotfiles-76bf046d035c">for</a> <a href="https://zachholman.com/2010/08/dotfiles-are-meant-to-be-forked/">tracking</a> <a href="https://github.com/ryanb/dotfiles">dotfiles</a> revolve around a dedicated dotfile directory with symlinks to the home directory. (Or symlinks to anywhere, really. This method does have the benefit of allowing you to add config files outside <code>~</code>.)
This is unnecessarily cumbersome. It requires you to have some sort of an install script or, worse yet, <a href="https://www.gnu.org/software/stow/">a</a> <a href="https://github.com/deadc0de6/dotdrop">program</a> <a href="https://github.com/jbernard/dotfiles">for</a> <a href="https://github.com/andsens/homeshick">managing</a> <a href="https://github.com/RichiH/vcsh">your</a> <a href="https://github.com/TheLocehiliosan/yadm">symlinks</a>. In addition to this, you still need Git. So why not just go with vanilla Git?</p>
<h2 id="troubleshooting">Troubleshooting</h2>
<ul>
<li>If you want to remove a file from Git, use <code>git rm --cached &lt;file&gt;</code>. If you do not pass the <code>--cached</code> option, the file will be removed from disk (you&rsquo;ll still be able to retrieve the lost data from <code>git reflog</code>).</li>
<li>Be wary of adding lots of files at once. In general with Git, I like to keep my commits as discrete as possible. This allows me to more easily undo or apply changes.</li>
<li>Be wary of unstaging added files. Use <code>git rm --cached</code> or a soft reset, <code>git reset</code>. If you do a hard reset (<code>git reset --hard HEAD</code>), the files will not merely be unstaged - they will also be deleted. If this happens, not even <code>git reflog</code> can help you (since the files were never a part of any commit). You will have to look through the blobs in <code>.git/lost-found/other</code> to retrieve the deleted files.</li>
</ul>

</content>
<p>
  
  <a href="https://chrisdempewolf.com/tags/software/">#software</a>
  
</p>

  </main>
  <footer>Forever in search of the farther shore.
</footer>

    
</body>

</html>
